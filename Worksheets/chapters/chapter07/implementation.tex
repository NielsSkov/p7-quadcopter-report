\chapter{Implementation}

The design of the controllers,  



\section{Scheduler}
Only two tasks are running on the microcontroller, the control algorithm and the communication. The handling of these tasks is however critical. The network introduces delays which sets a limit for the rate at which the control algorithms can be executed. It is also desirable for the control task to be executed periodically, and at any other time, the microcontroller should listen for new data on the network.\\
A scheduler can handle priorities and timing of task, for this purpose a real time operating system (RTOS) is used, called FreeRTOS.\\
The capabilities of this RTOS ranges beyond the needs in this project, but provides the tools needed, and constitutes a flexible base with room for future development.\\
In \autoref{lst:scheduler} PWM and communication is initialized, the two main tasks are created with appropriate priorities, the motors are activated by a start sequence and the task scheduler is started.

\begin{lstlisting}[style=customcpp,
                    caption={Code for initialization, creation of the different tasks, start sequence for the motors and call to the scheduler.}, 
                    label=lst:scheduler]
int main()
{
    // Initialization
    PWM_init(0);
    USART_Init(MYUBRR);
    ADC_Init();
    
    // Task Creation
    xTaskCreate(Controllers, "Control", 1000, NULL, configMAX_PRIORITIES - 1, NULL );
    xTaskCreate(Comunication, "Com", 1000, NULL, configMAX_PRIORITIES - 2, &xHandle);
    
    // Start sequence for the motor controllers
    _delay_ms(1000);
    int duty = 128;
    Set_PWM_duty(duty, duty, duty, duty);
    _delay_ms(10000);
 
    // Scheduler Start
    vTaskStartScheduler();
    return 0;
}
\end{lstlisting}

Once the task scheduler is started the program never returns to main again. The scheduler has a tick-rate which it uses to schedule and time tasks. The RTOS is set up to run with preemption, such that the higher priority task, controllers, can preempt the lower priority, communication, in order to achieve a periodic execution of the control algorithms. Since the XBee always sends data out on the RX-pin of the microcontroller, data will be lost if the communication is preempted. To make sure that there is always new data available for each execution of the control task, the execution frequency is chosen low enough such that at least one package is received in each period.

\section{Communication}
\begin{lstlisting}[style=customcpp,
                caption={Code for the comunication task.}, 
                label=lst:scheduler]
void Comunication(void *pvParameters)
{
    while (1)
    {
        int pack = 0;
        pack = CheckPackageArrival();
        if (pack)
            GetPackage();
    }
    vTaskDelete(NULL);
}
\end{lstlisting}


\section{Controllers}
\begin{lstlisting}[style=customcpp,
caption={Code for the controller task.}, 
label=lst:scheduler]
void Controllers(void *pvParameters)
{
    portTickType xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while (1)
    {
        Controller();
        count++;
        ApplyVelocities();
        if (reading)
        {
            vTaskDelete(xHandle);
            xTaskCreate(Comunication, "Com", 1000, NULL, configMAX_PRIORITIES - 2, &xHandle);
            reading = 0;
        }
        vTaskDelayUntil(&xLastWakeTime, 35);
    }
    vTaskDelete(NULL);
}
\end{lstlisting}


\begin{lstlisting}[style=customcpp,
caption={Code for the controllers.}, 
label=lst:scheduler]
    ...
    vel_ref_k[i] = -208.8*pos_e_k[i] + 198.2*pos_e_k1[i] + vel_ref_k1[i];
    ...
    xint_k[i] = T / 2 * (e_k[i] + e_k1[i]) + xint_k1[i];
    ...
    oint_k[i] = T / 2 * (o_k[i] + o_k1[i]) + oint_k1[i];
    ...

\end{lstlisting}