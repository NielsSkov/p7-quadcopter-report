\section{Communication Protocol}
%The main information necessary to transmit from the computer to the microcontroller, is the attitude, position, position reference and the translational velocity of the quadcopter. A created 
The transport layer protocol designed must ensure that transmitted packages can be detected and that erroneous packages are not utilized by the microcontroller, as complying with the functional requirements stated in \autoref{ch:functionalRequirements}.
%
%The Vicon system has a sampling rate of 100 Hz. A connectionless protocol can thereby be utilized, as it is sufficient to transmit the latest data to the micro controller instead of asking for a retransmission, e.g. if a package is lost or corrupt. Furthermore a retransmission will cause a delay in the system, this is not desired as this real time system is sensitive to delay.
As real-time features are desired for the prototype, the protocol chosen is UDP based. This is convenient as the system is sensitive to delays. A connection oriented protocol implies a longer package and a higher computation time, thus increasing the delay. Furthermore, A connectionless protocol laves more processor resources available for the controllers.

As the communication is only from the computer to the microcontroller, the protocol does not need a source port or destination addresses, as typically seen in a UDP protocol. Furthermore, it is decided not to change the length of the package relative to the gathered data. Making the length constant, only a start sequence is necessary and an end sequence is not included. As commonly in conenctionless protocols, package loss is not detected to avoid implementing a sequence number in the header of the package. A checksum, which constitutes the tail of the package, is considered enough for detecting corrupted information. 

These considerations simplify the protocol header and tail, resulting is shorter transmission and computation times and thus, leaving more computation time for the controllers to operate. The overall structure of a generated package is illustrated in \autoref{tab:Packagestructure}.
\begin{table}[H]\centering
\begin{tabular}{|>{\centering\arraybackslash}m{3cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|}
\hline
Start Sequence & Data & Checksum \\
\hline
\end{tabular}
\caption{The structure of the package.}
\label{tab:Packagestructure}
\end{table}

\subsubsection{Start Sequence}
The start sequence constitutes the header of the package and it is necessary for the micro controller to be able to distinguish between transmitted packages and arbitrary data. %As the microcontroller receives packages from the computer, a queue of packages are stored on the micro controller along with the generated noise.
%The start sequence enables the system to scan the information in the queue for the specific start sequence. 
If the start sequence is found in the received data, the microcontroller can then extract the information and checksum as they are paced after the start sequence and they have a fixed length. 
%It has not been deemed necessary to have an end byte, as the package length is fixed and the checksum ensures that an incorrect package is not utilized. Thus it is deemed redundant to check if the end of a package is the desired end.

The start sequence is set to three bytes and all the bits are set to ones. This consideration ensures the unlikeliness of finding a start sequence in the middle of a package as it is highly unlikely for the Vicon system to register two of the transmitted variables, which are place beside each other in the package, to be all ones at the same time. The start sequence can be seen in \autoref{tab:Packagestructure}.

%The queue of packages could be due to a slow package handler, as the sampling rate is set to low \fxnote{true? maybe som actual values}.
\subsubsection{Data}
The variables transmitted are the attitude (roll, pitch and yaw), the position ($x_{\mathrm{I}}$, $y_{\mathrm{I}}$ and $z_{\mathrm{I}}$), the position references and the translational velocity ($\dot{x}_{\mathrm{I}}$, $\dot{y}_{\mathrm{I}}$ and $\dot{z}_{\mathrm{I}}$).

The size of the roll, pitch and yaw are measured in radians and are contained in nine bits each. The first bit is the sign bit. The obtained number is multiplied by 100 to achieve a precision of 0.01 rad. Yielding a maximum value of 314, rounded down. This value is only measured by the Vicon system if the quadcopter does a 180 degree turn. If this occurs in the roll and pitch, it is not possible for the prototype to recover from being turned upside down. Therefore a byte is enough to contain the necessary data, that is, a maximum value of 255. However, if the quadcopter rotates 180 degrees in yaw, nine bites are needed to contain the variable. Nevertheless, it can be assumed that the controller is not to such a high value as discussed further in \autoref{chap:Control} \fxnote{discuss this in control}. One byte is therefore assigned for the yaw angle. When the package is received, the microcontroller casts the nine bits to a float and divides by a 100 transforming it back to radians.

The actual position coordinates (x, y and z) are measured in millimetres by the Vicon system and are contained in ten bits each. The first bit is utilized as a sign bit. By choosing a precision of centimeters, nine bits are sufficient to store the data. With this size, the position values are between $\pm$ 512 yielding a maximum distance of more than ten meters. Thus, making it sufficient for the prototype as it is operated in the Vicon room, see \autoref{cha:Systemdescription} \fxnote{ensure the dimensions of the vicon room is written in the system description}. The position reference utilizes the same units as the actual position and the same amount of bits for its variables.

The translational velocity ($\dot{x}$, $\dot{y}$ and $\dot{z}$) is contained in 11 bits, with the first bit as sign bit. Yielding a possibility of transmitting a value between $\pm$ 1024. The maximum velocity is 10 \si{m \cdot s^{-1}}, which is deemed sufficient. All these data, constitutes 15 bytes as shown in \autoref{tab:Packagestructure2}

 % It should be noted that both the computer and the micro controller are little endians. The most significant bit is therefore the sign bit in both systems. 
\subsubsection{Checksum}
If the start sequence is found and the next 15 bytes are extracted to be utilized in the controller, it is not certain that an actual full package is extracted. As explained earlier, a start sequence can be found in the middle of the package and arbitrary information is utilized. Furthermore it is possible that the package is sensitive to noise when transmitted from the computer to the microcontroller and the data gets therefore corrupted. It is necessary to check if the package contains the correct information. This is done by utilizing a checksum. An example of how the checksum is utilized and implemented can be seen in \autoref{tab:checksum}.  

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Bit array      & Overflow   & Byte 	   & Byte 	  & Byte		 \\ \hline
Part 1         & 		    & 00100001 & 01000000 & 01010000    \\ \hline
Part 2         & 		    & 00100001 & 01000001 & 01010001    \\ \hline
Part 3         & 		    & 00101001 & 01000000 & 01010000    \\ \hline
Part 4         & 		    & 00100011 & 01001000 & 01010001    \\ \hline
Part 5         & 		    & 10100001 & 01000010 & 01010100    \\ \hline
Part 1+2+3+4+5 & 01	        & 00110000 & 01001100 & 10010110 	 \\ \hline
Add overflow   & 		    & 00110000 & 01001100 & 10010111    \\ \hline
Checksum       & 		    & 11001111 & 10110011 & 01101000    \\ \hline
Check          & 		    & 11111111 & 11111111 & 11111111    \\ \hline
\end{tabular}
\caption{An example of how the checksum is utilized and implemented.}
\label{tab:checksum}
\end{table}
%The example in \autoref{tab:checksum} is a simplified version of the actual implemented checksum, as the original checksum is three bytes long.
The length of the checksum needs to be a multiple of the length of the data, which is 15 bytes. A big checksum, i.e. five bytes, reduces the probability of accepting an incorrect package as more bits are involved in checking the packages. The drawback is that the package size increases and so does the transmission time. On the other hand, having a small checksum, i.e. one byte, requires performing more computations and the chance of acquiring corrupted packages increase. As a compromise between the two approaches, a length of three bytes is chosen.

Before the computer transmits the package, the data is split up into five parts. The five parts are then summed. If a the result is bigger than what it can be represented with three bytes, the two most significant bits (column 2 in \autoref{tab:checksum}) are added to the summation. The checksum is generated by inverting the final summation result. The checksum is then placed at the end of the package, see \autoref{tab:Packagestructure}.

When the microcontroller examines the package for errors, it utilizes the checksum generated by the computer. The microcontroller divides the package in the same five parts and adds them together with the checksum. The package is considered correct if the outcome is a binary number formed by ones.
%the same steps as before except for the last step where the generated sum (with the added overflow) is inverted. Instead, the microcontroller adds the generated sum with the checksum received from the computer. If the outcome is a binary number , the package is recognized as correct.

%The length of the checksum needs to be a multiple of the length of the data, which is 15 bytes. The checksum can be five bytes. Thus splitting the package up into three parts. However, this increases the package size, which is not desired. By setting the checksum to be one or two bytes, the computation time increases when generating the checksum, which is not a desired property on the micro controller either. A length of three bytes is therefore set as a compromise.

It should be noted that the checksum's error handling is not bulletproof, as an error can cancel out another error. An example might be if a bit in part one is changed from false to true and another bit in the same position in part two is change from true to false. Then the checksum is the same and the error is not detected. \\

%The protocol for the transport layer, which is utilized on top of the xBee, has now been created.
The total package with the start sequence, data and checksum can be seen in \autoref{tab:Packagestructure2}. The start sequence is three bytes, the data is 15 bytes and the checksum is three bytes.
\begin{table}[H]
	\centering
	\begin{tabular}{llclllllllllllllll}
		\hline
		\multicolumn{2}{|c|}{}& \multicolumn{8}{c|}{Byte}                                                                                                                                                                           & \multicolumn{8}{c|}{Byte}                                                                                                                                                                                 \\ \hline
		\multicolumn{1}{|l|}{Byte} & \multicolumn{1}{l|}{Bit} & \multicolumn{1}{c|}{7} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{5} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{0} & \multicolumn{1}{|c|}{7} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{5} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{0} \\ \hline
		\multicolumn{1}{|c|}{0}    & \multicolumn{1}{c|}{0}   & \multicolumn{16}{c|}{Header}                                                                                                                                                                                                                                                                                                                                                                                        \\ \hline
		\multicolumn{1}{|c|}{2}    & \multicolumn{1}{c|}{16}  & \multicolumn{8}{c|}{}                                                                                                                                                                                 & \multicolumn{8}{c|}{$\phi$}                                                                                                                                                                                 \\ \hline
		\multicolumn{1}{|c|}{4}    & \multicolumn{1}{c|}{32}  & \multicolumn{1}{c|}{}  & \multicolumn{9}{c|}{$\theta$}                                                                                                                                                                                                  & \multicolumn{6}{c|}{$\psi$}                                                                                                                               \\ \hline
		\multicolumn{1}{|c|}{6}    & \multicolumn{1}{c|}{48}  & \multicolumn{3}{c|}{}                                                    & \multicolumn{10}{c|}{$x$}                                                                                                                                                                                                                                  & \multicolumn{3}{c|}{}                                                       \\ \hline
		\multicolumn{1}{|c|}{8}    & \multicolumn{1}{c|}{64}  & \multicolumn{7}{c|}{$y$}                                                                                                                                                     & \multicolumn{9}{c|}{$z$}                                                                                                                                                                                                             \\ \hline
		\multicolumn{1}{|c|}{10}   & \multicolumn{1}{c|}{80}  & \multicolumn{1}{c|}{}  & \multicolumn{10}{c|}{$x_{\mathrm{ref}}$}                                                                                                                                                                                                                          & \multicolumn{5}{c|}{$y_{\mathrm{ref}}$}                                                                                                  \\ \hline
		\multicolumn{1}{|c|}{12}   & \multicolumn{1}{c|}{96}  & \multicolumn{5}{c|}{}                                                                                                      & \multicolumn{10}{c|}{$z_{\mathrm{ref}}$}                                                                                                                                                                                                                              & \multicolumn{1}{c|}{}   \\ \hline
		\multicolumn{1}{|c|}{14}   & \multicolumn{1}{c|}{112} & \multicolumn{10}{c|}{$\dot{x}$}& \multicolumn{6}{c|}{$\dot{y}$}                                                       \\ \hline
		\multicolumn{1}{|c|}{16}   & \multicolumn{1}{c|}{128} & \multicolumn{5}{c|}{}                                                                                                      & \multicolumn{11}{c|}{$\dot{z}$}                                                                                                                                                                                                                                                        \\ \hline
		\multicolumn{1}{|c|}{18}   & \multicolumn{1}{c|}{144} & \multicolumn{16}{c|}{Checksum}                                                       \\ \hline
		\multicolumn{1}{|c|}{20}   & \multicolumn{1}{c|}{160} & \multicolumn{8}{c|}{}                                                                                                                                                                                 & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   \\ \hline
	\end{tabular}
	\caption{The generated package transmitted from the computer to the micro controller.}
	\label{tab:Packagestructure2}
\end{table}
