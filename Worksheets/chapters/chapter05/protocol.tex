\section{Communication Protocol}
The main information necessary to transmit from the computer to the micro controller, is the attitude, position, position reference and the translational velocity of the quadcopter. A created transport layer protocol is utilized to ensure transmitted packages can be detected and that erroneous packages is not utilized by the micro controller.

The Vicon system has a sampling rate of 100 Hz. A connectionless protocol can thereby be utilized, as it is sufficient to transmit the latest data to the micro controller instead of asking for a retransmission, e.g. if a package is lost or corrupt. Furthermore a retransmission will cause a delay in the system, this is not desired as this real time system is sensitive to delay.

\subsection{Package Structure}
The communication link is done between two nodes, the computer and the micro controller. Therefore the protocol does not need a source port or destination addresses, as typically seen in a connectionless UDP protocol. Furthermore, it is decided not to change the length of the package relative to the gathered data.\\
If a package is lost, the loss is not detected. However, this could be done by implementing a sequence number in the header of the package, but since the protocol is designed as a connectionless protocol, it is deemed unnecessary. As the length is constant a start sequence is only necessary and an end sequence is not included. These considerations simplifies the protocol header and tail, which results is shorter transmission time and less computation time. This is desired, as it will leave more computation time to the controllers and thereby ensuring better conditions for the stability of the quadcopter. It is decided that for the prototype a checksum is enough for detecting corrupted packages. An overall structure of a generated package is illustrated in \autoref{tab:Packagestructure}.

\begin{table}[H]\centering
\begin{tabular}{|>{\centering\arraybackslash}m{3cm}|>{\centering\arraybackslash}m{2cm}|>{\centering\arraybackslash}m{2cm}|}
\hline
Start Sequence & Data & Checksum \\
\hline
\end{tabular}
\caption{The structure of the package.}
\label{tab:Packagestructure}
\end{table}

\subsubsection{Start Sequence}
A start sequence is necessary for the micro controller to be able to differentiate between packages and noise. As the micro controller receives packages from the computer, a queue of packages are stored on the micro controller along with the generated noise. The start sequence enables the system to scan the information in the queue for the specific start sequence. If the start sequence is found, the micro controller can extract the package as the length is fixed. It has not been deemed necessary to have an end byte, as the package length is fixed and the checksum ensures that an incorrect package is not utilized. Thus it is deemed redundant to check if the end of a package is the desired end.

The start sequence is set to three bytes and all the bits are set to ones. These considerations are to ensure the unlikelyness of finding a start sequence in the middle of a package. As it is highly unlikely for the Vicon system to register two of the transmitted variables, which are place beside each other in the package, to be all ones at the same time. The header, the start sequence, can be seen included in \autoref{tab:Packagestructure}.

%The queue of packages could be due to a slow package handler, as the sampling rate is set to low \fxnote{true? maybe som actual values}.
\subsubsection{Data}
The variable which are transmitted from the computer to the micro controller, are the attitude (roll, pitch and yaw), the position (x, y and z), the position references and the translational velocity ($\dot{x}$, $\dot{y}$ and $\dot{z}$).

The size of the roll, pitch and yaw are measured in radians and are contained in nine bits each. The first bit of the nine is set up as the sign bit. As radians operates in decimal numbers, the number is multiplied by 100 to not remove essential data. Yielding a maximum value of 314, rounded down. This value is only measured by the Vicon system if the quadcopter does a 180 degree turn. If this occurs in the roll and pitch, it is not possible for the prototype to recover from being turned upside down. Therefore a byte is enough to contain the necessary data, as a 90 degree turn yield a value of 157. However, if the quadcopter rotates 180 degrees in yaw, nine bites are needed to contain the variable. Nevertheless, in this prototype the controller is not implemented for a 180 degree rotated yaw, this is discuss further in \autoref{chap:Control} \fxnote{discuss this in control}. One byte is therefore sufficient for the yaw. When the package is received the micro controller casts the nine bits to a float and divides by a 100 transforming it back to radians.

The actual position coordinates (x, y and z) are measured in millimetres by the Vicon system and are contained in ten bits each. The first bit is utilized as a sign bit. It is deemed unnecessary to measure the distance in millimetre. By changing the variable to centimetres, nine bits are sufficient, as values between $\pm$ 512 yields a maximum distance of approximately five meters. Thus, making it sufficient for this prototype, as the quadcopter is operated in the Vicon room, see \autoref{cha:Systemdescription} \fxnote{ensure the dimensions of the vicon room is written in the system description}. The position reference utilizes the same units as the actual position and the same amount of bits for its variables.

The translational velocity ($\dot{x}$, $\dot{y}$ and $\dot{z}$) is contained in 11 bits, with the first bit assigned to be a sign bit. Yielding a possibility of transmitting a value between $\pm$ 1024. This yields a maximum velocity of about 10 \si{m \cdot s^{-1}}, which is deemed sufficient. The total package with the start sequence, data and checksum can be seen in \autoref{tab:Packagestructure2}.

\begin{table}[H]
\centering
\begin{tabular}{llclllllllllllllll}
\hline
\multicolumn{2}{|c|}{}& \multicolumn{8}{c|}{Byte}                                                                                                                                                                           & \multicolumn{8}{c|}{Byte}                                                                                                                                                                                 \\ \hline
\multicolumn{1}{|l|}{Byte} & \multicolumn{1}{l|}{Bit} & \multicolumn{1}{c|}{7} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{5} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{0} & \multicolumn{1}{|c|}{7} & \multicolumn{1}{c|}{6} & \multicolumn{1}{c|}{5} & \multicolumn{1}{c|}{4} & \multicolumn{1}{c|}{3} & \multicolumn{1}{c|}{2} & \multicolumn{1}{c|}{1} & \multicolumn{1}{c|}{0} \\ \hline
\multicolumn{1}{|c|}{0}    & \multicolumn{1}{c|}{0}   & \multicolumn{16}{c|}{Header}                                                                                                                                                                                                                                                                                                                                                                                        \\ \hline
\multicolumn{1}{|c|}{2}    & \multicolumn{1}{c|}{16}  & \multicolumn{8}{c|}{}                                                                                                                                                                                 & \multicolumn{8}{c|}{$\phi$}                                                                                                                                                                                 \\ \hline
\multicolumn{1}{|c|}{4}    & \multicolumn{1}{c|}{32}  & \multicolumn{1}{c|}{}  & \multicolumn{9}{c|}{$\theta$}                                                                                                                                                                                                  & \multicolumn{6}{c|}{$\psi$}                                                                                                                               \\ \hline
\multicolumn{1}{|c|}{6}    & \multicolumn{1}{c|}{48}  & \multicolumn{3}{c|}{}                                                    & \multicolumn{10}{c|}{$x$}                                                                                                                                                                                                                                  & \multicolumn{3}{c|}{}                                                       \\ \hline
\multicolumn{1}{|c|}{8}    & \multicolumn{1}{c|}{64}  & \multicolumn{7}{c|}{$y$}                                                                                                                                                     & \multicolumn{9}{c|}{$z$}                                                                                                                                                                                                             \\ \hline
\multicolumn{1}{|c|}{10}   & \multicolumn{1}{c|}{80}  & \multicolumn{1}{c|}{}  & \multicolumn{10}{c|}{$x_{\mathrm{ref}}$}                                                                                                                                                                                                                          & \multicolumn{5}{c|}{$y_{\mathrm{ref}}$}                                                                                                  \\ \hline
\multicolumn{1}{|c|}{12}   & \multicolumn{1}{c|}{96}  & \multicolumn{5}{c|}{}                                                                                                      & \multicolumn{10}{c|}{$z_{\mathrm{ref}}$}                                                                                                                                                                                                                              & \multicolumn{1}{c|}{}   \\ \hline
\multicolumn{1}{|c|}{14}   & \multicolumn{1}{c|}{112} & \multicolumn{10}{c|}{$\dot{x}$}& \multicolumn{6}{c|}{$\dot{y}$}                                                       \\ \hline
\multicolumn{1}{|c|}{16}   & \multicolumn{1}{c|}{128} & \multicolumn{5}{c|}{}                                                                                                      & \multicolumn{11}{c|}{$\dot{z}$}                                                                                                                                                                                                                                                        \\ \hline
\multicolumn{1}{|c|}{18}   & \multicolumn{1}{c|}{144} & \multicolumn{16}{c|}{Checksum}                                                       \\ \hline
\multicolumn{1}{|c|}{20}   & \multicolumn{1}{c|}{160} & \multicolumn{8}{c|}{}                                                                                                                                                                                 & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}  & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{}   \\ \hline
\end{tabular}
\caption{The generated package transmitted from the computer to the micro controller.}
\label{tab:Packagestructure2}
\end{table}

The start sequence is three bytes, the data is 15 bytes and the checksum is three bytes, as seen in \autoref{tab:Packagestructure2}.
 % It should be noted that both the computer and the micro controller are little endians. The most significant bit is therefore the sign bit in both systems. 
\subsubsection{Checksum}
If the start sequence is found and the next 15 bytes are extracted to be utilized in the controller, it is not certain that an actual full package is extracted. As explained earlier, a start sequence can be found in the middle of the package and arbitrary information is utilized. Furthermore it is possible that the package is receptive to noise when transmitted from the computer to the micro controller and the data therefore gets corrupted. It is necessary to check if the package contains the expected information. This is done by utilizing a checksum. An example of how the checksum is utilized and implemented can be seen in \autoref{tab:checksum}.  

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Bit array  & Carry   & Byte 	& Byte 	   & Byte		 \\ \hline
Part 1     & 		 & 00100001 & 01000000 & 01010000    \\ \hline
Part 2     & 		 & 00100001 & 01000001 & 01010001    \\ \hline
Part 3     & 		 & 00101001 & 01000000 & 01010000    \\ \hline
Part 4     & 		 & 00100011 & 01001000 & 01010001    \\ \hline
Part 5     & 		 & 10100001 & 01000010 & 01010100    \\ \hline
Part 1+2+3+4+5 & 01	 & 00110000 & 01001100 & 10010110 	 \\ \hline
Add carry  & 		 & 00110000 & 01001100 & 10010111    \\ \hline
Checksum   & 		 & 11001111 & 10110011 & 01101000    \\ \hline
Check      & 		 & 11111111 & 11111111 & 11111111    \\ \hline
\end{tabular}
\caption{An example of how the checksum is utilized and implemented.}
\label{tab:checksum}
\end{table}
%The example in \autoref{tab:checksum} is a simplified version of the actual implemented checksum, as the original checksum is three bytes long.

Before the computer transmits the package, the data is split up into five parts. The five parts is then summed, which can result in a carry. If a carry occurs, it is removed and then added to the summation as a bit with value 1. The generated sum with the added carry, is then inverted. The generated checksum is then placed at the end of the package, see \autoref{tab:Packagestructure}.

When the microcontroller examines the package for errors, it utilizes the checksum generated by the computer. The micro controller executes the same steps as before except for the last step where the generated sum (with an added carry) is inverted. Instead, the microcontroller adds the generated sum with the checksum received from the computer. If the outcome is all bits of ones, the package is recognized as correct.

The length of the checksum needs to be a multiple of the length of the data, which is 15 bytes in this case. The checksum can be five bytes. Thus splitting the package up into three parts. However, this increases the package size, which is not desired. By setting the checksum to be one or two bytes, the computation time increases when generating the checksum, which is not a desired property on the micro controller either. A length of three bytes is therefore set as a compromise.

%The checksum's error handling is not bulletproof, as an error can cancel out another error. An example might be if a bit in part one is changed from false to true and another bit in the same position in part two is change from true to false. Then the checksum is the same and the error is not detected. 
%
%The protocol for the transport layer, which is utilized on top of the xBee, has now been created.